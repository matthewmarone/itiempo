type Mutation {
  setupNewAccount: Employee! @function(name: "GraphQLResolver-${env}")
  createUser(input: CreateUserInput!): Employee
    @function(name: "GraphQLResolver-${env}")
  updateUserRole(
    username: ID!
    employeeId: ID!
    managerIds: [String!]!
    roles: [Role!]!
    previousRoles: [Role!]!
    _version: Int!
  ): Employee @function(name: "GraphQLResolver-${env}")
  updateEmpl(input: emplInput!): Employee
    @function(name: "GraphQLResolver-${env}")
}
type Company
  @model(subscriptions: { level: off })
  @auth(
    rules: [
      # Allows creation only through GraphQLResolver (setupNewAccount)
      { allow: private, provider: iam, operations: [create, update, read] }
      {
        # Allow only company owners, and admins to update company info
        allow: groups
        groupsField: "allowUpdate"
        operations: [update]
      }
      {
        # Allow all memebers of a company to read
        allow: owner
        ownerField: "id"
        identityClaim: "cId"
        operations: [read]
      }
      {
        allow: groups
        groups: ["ForbiddenGroup"]
        operations: [create, delete]
      }
    ]
  ) {
  id: ID!
  name: String
  website: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  # allowUpdate is populated dynamically through the resolver to include:
  # Owener-${cId} and Admin-${cId}
  allowUpdate: [String]
    @auth(
      rules: [
        # Allows it to be set only once through setupNewAccount
        {
          allow: private
          provider: iam
          operations: [create, update, read, delete]
        }
        # Don't allow users access to modify
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
}
type Employee
  @model(subscriptions: { level: off })
  @key(
    name: "byCompany"
    fields: ["companyId", "email"]
    queryField: "listEmployeesByEmail"
  )
  @auth(
    rules: [
      # Only allow GraphQLResolver (setupNewAccount, addUser) to create
      { allow: private, provider: iam, operations: [create, update, read] }
      # All creating, editing and deleting would be done through GraphQLResolver
      {
        allow: groups
        groups: ["ForbiddenGroup"]
        operations: [create, update, delete]
      }
      {
        # Allow the employee itself to read it's own record
        allow: owner
        ownerField: "id"
        identityClaim: "eId"
        operations: [read]
      }
      {
        # Allow the employee's primary manager to read
        allow: owner
        ownerField: "primaryManagerId"
        identityClaim: "eId"
        operations: [read]
      }
      {
        # Allow all other managers to read
        allow: groups
        groupClaim: "eId"
        groupsField: "managerIds"
        operations: [read]
      }
      {
        # For future groups like accountant or super manager
        allow: groups
        groupsField: "allowRead"
        operations: [read]
      }
      {
        # Allow company admins/owners full access, updates handled through GraphQLResolver
        allow: groups
        groupsField: "allowFull"
        operations: [read]
      }
    ]
  ) {
  id: ID!
  username: String! # Write once, implemented in GraphQLResolver
  profilePhoto: String
  email: AWSEmail! # Restricted field, implemented in GraphQLResolver
  email_2: AWSEmail
  firstName: String
  lastName: String
  phone: String
  phone_2: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  jobTitle: String
  payRates: [PayRate!] # Restricted field, implemented in GraphQLResolver
  roles: [Role!]! # Restricted field, implemented in GraphQLResolver
  companyId: ID! # Write once, implemented in GraphQLResolver
  primaryManagerId: ID! # Restricted field, implemented in GraphQLResolver
  managerIds: [ID!] # Restricted field, implemented in GraphQLResolver
  allowRead: [String!]! # Write once, implemented in GraphQLResolver
  allowFull: [String!]! # Write once, implemented in GraphQLResolver
  inactive: Boolean
}
type TimeRecord
  @model(subscriptions: { level: off })
  @key(
    name: "byEmployeeTimestamp"
    fields: ["employeeId", "timestampIn"]
    queryField: "listEmployeeTimeRecords"
  )
  @key(
    name: "byCompanyTimestamp"
    fields: ["companyId", "timestampIn"]
    queryField: "listCompanyTimeRecords"
  )
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: private, provider: userPools }
    ]
  ) {
  id: ID!
  employeeId: ID!
  companyId: ID!
  primaryManagerId: ID!
  managerIds: [ID!]
  timestampIn: AWSTimestamp!
  timestampOut: AWSTimestamp
  photoIn: String
  photoOut: String
  noteIn: String
  noteOut: String
  rate: PayRate
}
type PayRate {
  name: String
  amount: Float!
  isHourly: Boolean!
  isDefault: Boolean!
}
enum Role {
  Owner
  Admin
  Manager
  Employee
}
## Input types
input CreateUserInput {
  profilePhoto: String
  email: AWSEmail!
  email_2: AWSEmail
  firstName: String
  lastName: String
  phone: String
  phone_2: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  jobTitle: String
  payRates: [PayRateUpsertInput!]
  roles: [Role!]!
  companyId: ID!
  primaryManagerId: ID!
  managerIds: [ID!]
}
input emplInput {
  id: ID!
  username: String! # Write once, implemented in GraphQLResolver
  profilePhoto: String
  email: AWSEmail # Restricted field, implemented in GraphQLResolver
  email_2: AWSEmail
  firstName: String
  lastName: String
  phone: String
  phone_2: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  jobTitle: String
  payRates: [PayRateUpsertInput!] # Restricted field, implemented in GraphQLResolver
  roles: [Role!]! # Restricted field, implemented in GraphQLResolver
  updateRoles:[Role!]
  companyId: ID! # Write once, implemented in GraphQLResolver
  primaryManagerId: ID! # Restricted field, implemented in GraphQLResolver
  managerIds: [ID!] # Restricted field, implemented in GraphQLResolver
  allowRead: [String!] # Write once, implemented in GraphQLResolver
  allowFull: [String!] # Write once, implemented in GraphQLResolver
  _version: Int!
}
input PayRateUpsertInput {
  name: String
  amount: Float!
  isHourly: Boolean!
  isDefault: Boolean!
}
