type Mutation {
  setupNewAccount: Employee! @function(name: "GraphQLResolver-${env}")
  createUser(input: CreateUserInput!): Employee
    @function(name: "GraphQLResolver-${env}")
  updateUserRole(
    username: ID!
    employeeId: ID!
    managerIds: [String!]!
    roles: [Role!]!
    previousRoles: [Role!]!
    _version: Int!
  ): Employee @function(name: "GraphQLResolver-${env}")
}
type Company
  @model(subscriptions: { level: off })
  @auth(
    rules: [
      # Allows creation only through GraphQLResolver (setupNewAccount)
      { allow: private, provider: iam, operations: [create, update, read] }
      {
        # Allow only company owners, and admins to update company info
        allow: groups
        groupsField: "allowUpdate"
        operations: [update]
      }
      {
        # Allow all memebers of a company to read
        allow: owner
        ownerField: "id"
        identityClaim: "cId"
        operations: [read]
      }
      {
        allow: groups
        groups: ["ForbiddenGroup"]
        operations: [create, delete]
      }
    ]
  ) {
  id: ID!
  name: String
  website: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  # allowUpdate is populated dynamically through the resolver to include:
  # Owener-${cId} and Admin-${cId}
  allowUpdate: [String]
    @auth(
      rules: [
        # Allows it to be set only once through setupNewAccount
        {
          allow: private
          provider: iam
          operations: [create, update, read, delete]
        }
        # Allow all with access to read
        { allow: private, provider: userPools, operations: [read] }
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
}
type Employee
  @model(subscriptions: { level: off })
  @key(
    name: "byCompany"
    fields: ["companyId", "email"]
    queryField: "listEmployeesByEmail"
  )
  @auth(
    rules: [
      # Only allow GraphQLResolver (setupNewAccount, addUser) to create
      {
        allow: private
        provider: iam
        operations: [create, update, read, delete]
      }
      {
        # Allow the employee itself to update and read it's own rec.
        allow: owner
        ownerField: "id"
        identityClaim: "eId"
        operations: [read, update]
      }
      {
        # Allow the employee's manager full access
        allow: owner
        ownerField: "primaryManagerId"
        identityClaim: "eId"
        operations: [read, update]
      }
      {
        # Allow company admins/owners full access
        allow: groups
        groupClaim: "eId"
        groupsField: "managerIds"
        operations: [read, update]
      }
      {
        # For future groups like accountant or super manager
        allow: groups
        groupsField: "allowRead"
        operations: [read]
      }
      {
        # Allow company admins/owners full access
        allow: groups
        groupsField: "allowFull"
        operations: [read, update]
      }
      # # Block cognito user from creating and deleting
      # {
      #   allow: groups
      #   groups: ["ForbiddenGroup"]
      #   operations: [create, delete]
      # }
    ]
  ) {
  id: ID!
  username: String
    @auth(
      rules: [
        # This field is set at creation
        { allow: private, provider: iam, operations: [create, read] }
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  profilePhoto: String
  email: AWSEmail
    @auth(
      rules: [
        # This field is set at creation
        { allow: private, provider: iam, operations: [create, update, read] }
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  email_2: AWSEmail
  firstName: String
  lastName: String
  phone: String
  phone_2: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  jobTitle: String
  payRates: [PayRate!]
    @auth(
      rules: [
        # Only allow GraphQLResolver (setupNewAccount, addUser) to create
        { allow: private, provider: iam, operations: [create, update, read] }
        # allow anyone with access to read
        # { allow: private, provider: userPools, operations: [read] }
        {
          # Allow the employee's manager to update
          allow: owner
          ownerField: "primaryManagerId"
          identityClaim: "eId"
          operations: [update]
        }
        {
          # Allow the employee's manager to update
          allow: groups
          groupClaim: "eId"
          groupsField: "managerIds"
          operations: [update]
        }
        {
          # Allow company admins/owners full access
          allow: groups
          groupsField: "allowFull"
          operations: [update]
        }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  roles: [Role!]
    @auth(
      rules: [
        # Only allow GraphQLResolver to create, read, update
        { allow: private, provider: iam, operations: [create, update, read] }
        # Allow all with access to read
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  companyId: ID
    @auth(
      rules: [
        # This field is set at creation
        { allow: private, provider: iam, operations: [create, read] }
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  primaryManagerId: ID
    @auth(
      rules: [
        # Only allow GraphQLResolver (setupNewAccount, addUser) to create
        { allow: private, provider: iam, operations: [create, update, read] }
        # allow anyone with access to read
        # { allow: private, provider: userPools, operations: [read] }
        {
          # Allow the employee's manager to update
          allow: owner
          ownerField: "primaryManagerId"
          identityClaim: "eId"
          operations: [update]
        }
        {
          # Allow the employee's manager to update
          allow: groups
          groupClaim: "eId"
          groupsField: "managerIds"
          operations: [update]
        }
        {
          # Allow company admins/owners full access
          allow: groups
          groupsField: "allowFull"
          operations: [update]
        }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  managerIds: [ID!]
    @auth(
      rules: [
        # Only allow GraphQLResolver (setupNewAccount, addUser) to create
        { allow: private, provider: iam, operations: [create, update, read] }
        # allow anyone with access to read
        # { allow: private, provider: userPools, operations: [read] }
        {
          # Allow the employee's manager to update
          allow: owner
          ownerField: "primaryManagerId"
          identityClaim: "eId"
          operations: [update]
        }
        {
          # Allow the employee's manager to update
          allow: groups
          groupClaim: "eId"
          groupsField: "managerIds"
          operations: [update]
        }
        {
          # Allow company admins/owners full access
          allow: groups
          groupsField: "allowFull"
          operations: [update]
        }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  allowRead: [String]
    @auth(
      rules: [
        # Allows it to be set only once through setupNewAccount or createUser
        { allow: private, provider: iam, operations: [create, read] }
        # Allow all with access to read
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
  allowFull: [String]
    @auth(
      rules: [
        # Allows it to be set only once through setupNewAccount or createUser
        { allow: private, provider: iam, operations: [create, read] }
        # Allow all with access to read
        # { allow: private, provider: userPools, operations: [read] }
        # Block cognito users from modifiying
        {
          allow: groups
          groups: ["ForbiddenGroup"]
          operations: [create, update, delete]
        }
      ]
    )
}
type TimeRecord
  @model(subscriptions: { level: off })
  @key(
    name: "byEmployeeTimestamp"
    fields: ["employeeId", "timestampIn"]
    queryField: "listEmployeeTimeRecords"
  )
  @key(
    name: "byCompanyTimestamp"
    fields: ["companyId", "timestampIn"]
    queryField: "listCompanyTimeRecords"
  )
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: private, provider: userPools }
    ]
  ) {
  id: ID!
  employeeId: ID!
  companyId: ID!
  primaryManagerId: ID!
  managerIds: [ID!]
  timestampIn: AWSTimestamp!
  timestampOut: AWSTimestamp
  photoIn: String
  photoOut: String
  noteIn: String
  noteOut: String
  rate: PayRate
}
type PayRate {
  name: String
  amount: Float!
  isHourly: Boolean!
  isDefault: Boolean!
}
enum Role {
  Owner
  Admin
  Manager
  Employee
}
## Input types
input CreateUserInput {
  profilePhoto: String
  email: AWSEmail!
  email_2: AWSEmail
  firstName: String
  lastName: String
  phone: String
  phone_2: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  zip: String
  country: String
  jobTitle: String
  payRates: [PayRateCreateInput!]
  roles: [Role!]!
  companyId: ID!
  primaryManagerId: ID!
}
input PayRateCreateInput {
  name: String
  amount: Float!
  isHourly: Boolean!
  isDefault: Boolean!
}
